{"version":3,"file":"serializr.min.js","sources":["../src/utils/invariant.js","../src/utils/utils.js","../src/api/getDefaultModelSchema.js","../src/api/setDefaultModelSchema.js","../src/api/createModelSchema.js","../src/types/primitive.js","../src/constants.js","../src/api/serializable.js","../src/core/serialize.js","../src/core/Context.js","../src/core/deserialize.js","../src/types/object.js","../src/types/reference.js","../src/types/list.js","../src/api/createSimpleSchema.js","../src/core/cancelDeserialize.js","../src/core/update.js","../src/types/identifier.js","../src/types/date.js","../src/types/alias.js","../src/types/custom.js","../src/types/map.js","../src/types/mapAsArray.js","../src/types/raw.js"],"sourcesContent":["var formatters = {\n    j: function json(v) {\n        try {\n            return JSON.stringify(v)\n        } catch (error) {\n            return \"[UnexpectedJSONParseError]: \" + error.message\n        }\n    }\n}\n\nexport default function invariant(condition, message) {\n    if (!condition) {\n        var variables = Array.prototype.slice.call(arguments, 2)\n        var variablesToLog = []\n\n        var index = 0\n        var formattedMessage = message.replace(/%([a-zA-Z%])/g, function messageFormatter(match, format) {\n            if (match === \"%%\") return match\n\n            var formatter = formatters[format]\n\n            if (typeof formatter === \"function\") {\n                var variable = variables[index++]\n\n                variablesToLog.push(variable)\n\n                return formatter(variable)\n            }\n\n            return match\n        })\n\n        if (console && variablesToLog.length > 0) {\n            // eslint-disable-next-line no-console\n            console.log.apply(console, variablesToLog)\n        }\n\n        throw new Error(\"[serializr] \" + (formattedMessage || \"Illegal State\"))\n    }\n}\n","import invariant from \"./invariant\"\n\nexport function GUARDED_NOOP(err) {\n    if (err) // unguarded error...\n        throw new Error(err)\n}\n\nexport function once(fn) {\n    var fired = false\n    return function () {\n        if (!fired) {\n            fired = true\n            return fn.apply(null, arguments)\n        }\n        invariant(false, \"callback was invoked twice\")\n    }\n}\n\nexport function parallel(ar, processor, cb) {\n    // TODO: limit parallelization?\n    if (ar.length === 0)\n        return void cb(null, [])\n    var left = ar.filter(function(){ return true }).length // only count items processed by forEach\n    var resultArray = []\n    var failed = false\n    var processorCb = function (idx, err, result) {\n        if (err) {\n            if (!failed) {\n                failed = true\n                cb(err)\n            }\n        } else {\n            resultArray[idx] = result\n            if (--left === 0)\n                cb(null, resultArray)\n        }\n    }\n    ar.forEach(function (value, idx) {\n        processor(value, processorCb.bind(null, idx), idx)\n    })\n}\n\nexport function isPrimitive(value) {\n    if (value === null)\n        return true\n    return typeof value !== \"object\" && typeof value !== \"function\"\n}\n\nexport function isModelSchema(thing) {\n    return thing && thing.factory && thing.props\n}\n\nexport function isPropSchema(thing) {\n    return thing && thing.serializer && thing.deserializer\n}\n\nexport function isAliasedPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && !!propSchema.jsonname\n}\n\nexport function isIdentifierPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && propSchema.identifier === true\n}\n\nexport function isAssignableTo(actualType, expectedType) {\n    while (actualType) {\n        if (actualType === expectedType)\n            return true\n        actualType = actualType.extends\n    }\n    return false\n}\n\nexport function isMapLike(thing) {\n    return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\n}\n\nexport function getIdentifierProp(modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    // optimization: cache this lookup\n    while (modelSchema) {\n        for (var propName in modelSchema.props)\n            if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\n                return propName\n        modelSchema = modelSchema.extends\n    }\n    return null\n}\n\nexport function processAdditionalPropArgs(propSchema, additionalArgs) {\n    if (additionalArgs) {\n        invariant(isPropSchema(propSchema), \"expected a propSchema\")\n        var argNames = [\"beforeDeserialize\", \"afterDeserialize\"]\n        argNames.forEach(function(argName) {\n            if (typeof additionalArgs[argName] === \"function\") {\n                propSchema[argName] = additionalArgs[argName]\n            }\n        })\n    }\n    return propSchema\n}\n\nexport { invariant }\n","import { isModelSchema } from \"../utils/utils\"\n\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\nexport default function getDefaultModelSchema(thing) {\n    if (!thing)\n        return null\n    if (isModelSchema(thing))\n        return thing\n    if (isModelSchema(thing.serializeInfo))\n        return thing.serializeInfo\n    if (thing.constructor && thing.constructor.serializeInfo)\n        return thing.constructor.serializeInfo\n}\n","import { invariant, isModelSchema } from \"../utils/utils\"\n\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\nexport default function setDefaultModelSchema(clazz, modelSchema) {\n    invariant(isModelSchema(modelSchema))\n    return clazz.serializeInfo = modelSchema\n}\n","import { invariant } from \"../utils/utils\"\nimport getDefaultModelSchema from \"./getDefaultModelSchema\"\nimport setDefaultModelSchema from \"./setDefaultModelSchema\"\n\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\nexport default function createModelSchema(clazz, props, factory) {\n    invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\")\n    invariant(typeof clazz === \"function\", \"expected constructor function\")\n    var model = {\n        targetClass: clazz,\n        factory: factory || function() {\n            return new clazz()\n        },\n        props: props\n    }\n    // find super model\n    if (clazz.prototype.constructor !== Object) {\n        var s = getDefaultModelSchema(clazz.prototype.constructor)\n        if (s && s.targetClass !== clazz)\n            model.extends = s\n    }\n    setDefaultModelSchema(clazz, model)\n    return model\n}\n","import {invariant, processAdditionalPropArgs} from \"../utils/utils\"\nimport { isPrimitive } from \"../utils/utils\"\n\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\nexport default function primitive(additionalArgs) {\n    var result = {\n        serializer: function (value) {\n            invariant(isPrimitive(value), \"this value is not primitive: \" + value)\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            if (!isPrimitive(jsonValue))\n                return void done(\"[serializr] this value is not primitive: \" + jsonValue)\n            return void done(null, jsonValue)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import primitive from \"./types/primitive\"\n\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\nexport var SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true }\n\nexport var _defaultPrimitiveProp = primitive()\n","import { invariant, isPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport primitive from \"../types/primitive\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport createModelSchema from \"../api/createModelSchema\"\n\n// Ugly way to get the parameter names since they aren't easily retrievable via reflection\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg\nvar ARGUMENT_NAMES = /([^\\s,]+)/g\n\nfunction getParamNames(func) {\n    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\")\n    var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES)\n    if(result === null)\n        result = []\n    return result\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n    invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\")\n    // Fix for @serializable used in class constructor params (typescript)\n    var factory\n    if (propName === undefined && typeof target === \"function\"\n        && target.prototype\n        && descriptor !== undefined && typeof descriptor === \"number\") {\n        invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\")\n        invariant(propSchema.jsonname, \"Constructor params must use alias(name)\")\n        var paramNames = getParamNames(target)\n        if (paramNames.length >= descriptor) {\n            propName = paramNames[descriptor]\n            propSchema.paramNumber = descriptor\n            descriptor = undefined\n            target = target.prototype\n            // Create a factory so the constructor is called properly\n            factory = function(context) {\n                var params = []\n                for (var i = 0; i < target.constructor.length; i++) {\n                    Object.keys(context.modelSchema.props).forEach(function (key) {\n                        var prop = context.modelSchema.props[key]\n                        if (prop.paramNumber === i) {\n                            params[i] = context.json[prop.jsonname]\n                        }\n                    })\n                }\n\n                return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))\n            }\n        }\n    }\n    invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\")\n    var info = getDefaultModelSchema(target)\n\n    if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\n        info = createModelSchema(target.constructor, {}, factory)\n    if (info && info.targetClass !== target.constructor)\n        // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n        info = createModelSchema(target.constructor, {}, factory)\n    info.props[propName] = propSchema\n    // MWE: why won't babel work without?\n    if (descriptor && !descriptor.get && !descriptor.set)\n        descriptor.writable = true\n    return descriptor\n}\n\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\nexport default function serializable(arg1, arg2, arg3) {\n    if (arguments.length === 1) {\n        // decorated with propSchema\n        var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1\n        invariant(isPropSchema(propSchema), \"@serializable expects prop schema\")\n        return serializableDecorator.bind(null, propSchema)\n    } else {\n        // decorated without arguments, treat as primitive\n        return serializableDecorator(primitive(), arg1, arg2, arg3)\n    }\n}\n","import { invariant, isPrimitive } from \"../utils/utils\"\nimport createModelSchema from \"../api/createModelSchema\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport setDefaultModelSchema from \"../api/setDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\nexport default function serialize(arg1, arg2) {\n    invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\")\n    var thing = arguments.length === 1 ? arg1 : arg2\n    var schema = arguments.length === 1 ? null : arg1\n    if (Array.isArray(thing)) {\n        if (thing.length === 0)\n            return [] // don't bother finding a schema\n        else if (!schema)\n            schema = getDefaultModelSchema(thing[0])\n    } else if (!schema) {\n        schema = getDefaultModelSchema(thing)\n    }\n    invariant(!!schema, \"Failed to find default schema for \" + arg1)\n    if (Array.isArray(thing))\n        return thing.map(function (item) {\n            return serializeWithSchema(schema, item)\n        })\n    return serializeWithSchema(schema, thing)\n}\n\nexport function serializeWithSchema(schema, obj) {\n    invariant(schema && typeof schema === \"object\", \"Expected schema\")\n    invariant(obj && typeof obj === \"object\", \"Expected object\")\n    var res\n    if (schema.extends)\n        res = serializeWithSchema(schema.extends, obj)\n    else {\n        // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n        res = {}\n    }\n    Object.keys(schema.props).forEach(function (key) {\n        var propDef = schema.props[key]\n        if (key === \"*\") {\n            invariant(propDef === true, \"prop schema '*' can only be used with 'true'\")\n            serializeStarProps(schema, obj, res)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonValue = propDef.serializer(obj[key], key, obj)\n        if (jsonValue === SKIP){\n            return\n        }\n        res[propDef.jsonname || key] = jsonValue\n    })\n    return res\n}\n\nexport function serializeStarProps(schema, obj, target) {\n    for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n        var value = obj[key]\n        // when serializing only serialize primitive props. Assumes other props (without schema) are local state that doesn't need serialization\n        if (isPrimitive(value))\n            target[key] = value\n    }\n}\n\n/**\n * The `serializeAll` decorator can be used on a class to signal that all primitive properties should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { a: 3, b: undefined, c: 5 });\n */\nexport function serializeAll(target) {\n    invariant(arguments.length === 1 && typeof target === \"function\", \"@serializeAll can only be used as class decorator\")\n\n    var info = getDefaultModelSchema(target)\n    if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n        info = createModelSchema(target, {})\n        setDefaultModelSchema(target, info)\n    }\n\n    getDefaultModelSchema(target).props[\"*\"] = true\n    return target\n}\n","import { GUARDED_NOOP, once, invariant, isAssignableTo } from \"../utils/utils\"\n\nvar rootContextCache = new Map()\n\nexport default function Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n    this.parentContext = parentContext\n    this.isRoot = !parentContext\n    this.pendingCallbacks = 0\n    this.pendingRefsCount = 0\n    this.onReadyCb = onReadyCb || GUARDED_NOOP\n    this.json = json\n    this.target = null // always set this property using setTarget\n    this.hasError = false\n    this.modelSchema = modelSchema\n    if (this.isRoot) {\n        this.rootContext = this\n        this.args = customArgs\n        this.pendingRefs = {} // uuid: [{ modelSchema, uuid, cb }]\n        this.resolvedRefs = {} // uuid: [{ modelSchema, value }]\n    } else {\n        this.rootContext = parentContext.rootContext\n        this.args = parentContext.args\n    }\n}\n\nContext.prototype.createCallback = function (fn) {\n    this.pendingCallbacks++\n    // once: defend against user-land calling 'done' twice\n    return once(function (err, value) {\n        if (err) {\n            if (!this.hasError) {\n                this.hasError = true\n                this.onReadyCb(err)\n                rootContextCache.delete(this)\n            }\n        } else if (!this.hasError) {\n            fn(value)\n            if (--this.pendingCallbacks === this.pendingRefsCount) {\n                if (this.pendingRefsCount > 0) {\n                    // all pending callbacks are pending reference resolvers. not good.\n                    this.onReadyCb(new Error(\n                        \"Unresolvable references in json: \\\"\" +\n                        Object.keys(this.pendingRefs).filter(function (uuid) {\n                            return this.pendingRefs[uuid].length > 0\n                        }, this).join(\"\\\", \\\"\") +\n                        \"\\\"\"\n                    ))\n                    rootContextCache.delete(this)\n                } else {\n                    this.onReadyCb(null, this.target)\n                    rootContextCache.delete(this)\n                }\n            }\n        }\n    }.bind(this))\n}\n\n// given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\nContext.prototype.await = function (modelSchema, uuid, callback) {\n    invariant(this.isRoot)\n    if (uuid in this.resolvedRefs) {\n        var match = this.resolvedRefs[uuid].filter(function (resolved) {\n            return isAssignableTo(resolved.modelSchema, modelSchema)\n        })[0]\n        if (match)\n            return void callback(null, match.value)\n    }\n    this.pendingRefsCount++\n    if (!this.pendingRefs[uuid])\n        this.pendingRefs[uuid] = []\n    this.pendingRefs[uuid].push({\n        modelSchema: modelSchema,\n        uuid: uuid,\n        callback: callback\n    })\n}\n\n// given a model schema, uuid and value, resolve all references that where looking for this object\nContext.prototype.resolve = function (modelSchema, uuid, value) {\n    invariant(this.isRoot)\n    if (!this.resolvedRefs[uuid])\n        this.resolvedRefs[uuid] = []\n    this.resolvedRefs[uuid].push({\n        modelSchema: modelSchema, value: value\n    })\n    if (uuid in this.pendingRefs) {\n        for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n            var opts = this.pendingRefs[uuid][i]\n            if (isAssignableTo(modelSchema, opts.modelSchema)) {\n                this.pendingRefs[uuid].splice(i, 1)\n                this.pendingRefsCount--\n                opts.callback(null, value)\n            }\n        }\n    }\n}\n\n// set target and update root context cache\nContext.prototype.setTarget = function (target) {\n    if (this.isRoot && this.target) {\n        rootContextCache.delete(this.target)\n    }\n    this.target = target\n    rootContextCache.set(this.target, this)\n}\n\n// call all remaining reference lookup callbacks indicating an error during ref resolution\nContext.prototype.cancelAwaits = function () {\n    invariant(this.isRoot)\n    var self = this\n    Object.keys(this.pendingRefs).forEach(function (uuid) {\n        self.pendingRefs[uuid].forEach(function (refOpts) {\n            self.pendingRefsCount--\n            refOpts.callback(new Error(\"Reference resolution canceled for \" + uuid))\n        })\n    })\n    this.pendingRefs = {}\n    this.pendingRefsCount = 0\n}\n\nexport function getTargetContext(target) {\n    return rootContextCache.get(target)\n}\n","/*\n * Deserialization\n */\nimport { invariant, isPrimitive, isModelSchema, parallel, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport { SKIP, _defaultPrimitiveProp } from \"../constants\"\nimport Context from \"./Context\"\n\nfunction schemaHasAlias(schema, name) {\n    for (var key in schema.props)\n        if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\n            return true\n    return false\n}\n\nfunction deserializeStarProps(schema, obj, json) {\n    for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n        var value = json[key]\n        // when deserializing we don't want to silently ignore 'unparseable data' to avoid\n        // confusing bugs\n        invariant(isPrimitive(value),\n            \"encountered non primitive value while deserializing '*' properties in property '\" +\n            key + \"': \" + value)\n        obj[key] = value\n    }\n}\n\n/**\n * Deserializes a json structure into an object graph.\n *\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserialization has\n *   finished. First argument is the optional error, second argument is the deserialized object\n *   (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the\n *   deserialization process. This can be used as dependency injection mechanism to pass in, for\n *   example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nexport default function deserialize(schema, json, callback, customArgs) {\n    invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\")\n    schema = getDefaultModelSchema(schema)\n    invariant(isModelSchema(schema), \"first argument should be model schema\")\n    if (Array.isArray(json)) {\n        var items = []\n        parallel(\n            json,\n            function (childJson, itemDone) {\n                var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs)\n                // instance is created synchronously so can be pushed\n                items.push(instance)\n            },\n            callback || GUARDED_NOOP\n        )\n        return items\n    } else\n        return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\n}\n\nexport function deserializeObjectWithSchema(parentContext, modelSchema, json, callback, customArgs) {\n    if (json === null || json === undefined || typeof json !== \"object\")\n        return void callback(null, null)\n    var context = new Context(parentContext, modelSchema, json, callback, customArgs)\n    var target = modelSchema.factory(context)\n    // todo async invariant\n    invariant(!!target, \"No object returned from factory\")\n    // TODO: make invariant?            invariant(schema.extends ||\n    // !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable\n    // supertype, but modelschema did not provide extends clause\")\n    context.setTarget(target)\n    var lock = context.createCallback(GUARDED_NOOP)\n    deserializePropsWithSchema(context, modelSchema, json, target)\n    lock()\n    return target\n}\n\nexport function deserializePropsWithSchema(context, modelSchema, json, target) {\n    if (modelSchema.extends)\n        deserializePropsWithSchema(context, modelSchema.extends, json, target)\n\n    function deserializeProp(propDef, jsonValue, propName) {\n\n        function setValue(value) {\n            if (value !== SKIP) {\n                target[propName] = value\n            }\n        }\n\n        function preProcess(resultCallback) {\n            return function (err, newValue) {\n                function finalCallback(errPreliminary, finalOrRetryValue) {\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\n                        typeof propDef.afterDeserialize === \"function\") {\n\n                        propDef.deserializer(\n                            finalOrRetryValue,\n                            preProcess(resultCallback),\n                            context,\n                            target[propName]\n                        )\n                    } else {\n                        resultCallback(errPreliminary, finalOrRetryValue)\n                    }\n                }\n\n                onAfterDeserialize(finalCallback, err, newValue, jsonValue, json,\n                    propName, context, propDef)\n            }\n        }\n\n        propDef.deserializer(\n            jsonValue,\n            // for individual props, use root context based callbacks\n            // this allows props to complete after completing the object itself\n            // enabling reference resolving and such\n            preProcess(context.rootContext.createCallback(setValue)),\n            context,\n            target[propName] // initial value\n        )\n    }\n\n    Object.keys(modelSchema.props).forEach(function (propName) {\n        var propDef = modelSchema.props[propName]\n\n        function callbackDeserialize(err, jsonValue) {\n            if (!err && jsonValue !== undefined) {\n                deserializeProp(propDef, jsonValue, propName)\n            }\n        }\n\n        if (propName === \"*\") {\n            invariant(propDef === true, \"prop schema '*' can only be used with 'true'\")\n            deserializeStarProps(modelSchema, target, json)\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp\n        if (propDef === false)\n            return\n        var jsonAttr = propDef.jsonname || propName\n        var jsonValue = json[jsonAttr]\n        onBeforeDeserialize(callbackDeserialize, jsonValue, json, jsonAttr, context, propDef)\n    })\n}\n\n\nexport function onBeforeDeserialize(\n    callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n\n    if (propDef && typeof propDef.beforeDeserialize === \"function\") {\n        propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context,\n            propDef)\n    } else {\n        callback(null, jsonValue)\n    }\n}\n\nexport function onAfterDeserialize(\n    callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n\n    if (propDef && typeof propDef.afterDeserialize === \"function\") {\n        propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue,\n            propNameOrIndex, context, propDef)\n    } else {\n        callback(err, newValue)\n    }\n}\n\n","import {invariant, isModelSchema, processAdditionalPropArgs} from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport serialize from \"../core/serialize\"\nimport { deserializeObjectWithSchema } from \"../core/deserialize\"\n\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function object(modelSchema, additionalArgs) {\n    invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    var result = {\n        serializer: function (item) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (item === null || item === undefined)\n                return item\n            return serialize(modelSchema, item)\n        },\n        deserializer: function (childJson, done, context) {\n            modelSchema = getDefaultModelSchema(modelSchema)\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema)\n            if (childJson === null || childJson === undefined)\n                return void done(null, childJson)\n            return void deserializeObjectWithSchema(context, modelSchema, childJson, done, additionalArgs)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import {invariant, isModelSchema, getIdentifierProp, processAdditionalPropArgs} from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\n\nfunction createDefaultRefLookup(modelSchema) {\n    return function resolve(uuid, cb, context) {\n        context.rootContext.await(modelSchema, uuid, cb)\n    }\n}\n\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction | AdditionalPropArgs} lookupFn optional function or additionalArgs object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function reference(target, lookupFn, additionalArgs) {\n    invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\")\n    var initialized = false\n    var childIdentifierAttribute\n    if (typeof lookupFn === \"object\" && additionalArgs === undefined) {\n        additionalArgs = lookupFn\n        lookupFn = undefined\n    }\n    function initialize() {\n        initialized = true\n        invariant(typeof target !== \"string\" || lookupFn && typeof lookupFn === \"function\", \"if the reference target is specified by attribute name, a lookup function is required\")\n        invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function or additional arguments object\")\n        if (typeof target === \"string\")\n            childIdentifierAttribute = target\n        else {\n            var modelSchema = getDefaultModelSchema(target)\n            invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema)\n            lookupFn = lookupFn || createDefaultRefLookup(modelSchema)\n            childIdentifierAttribute = getIdentifierProp(modelSchema)\n            invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\")\n        }\n    }\n    var result = {\n        serializer: function (item) {\n            if (!initialized)\n                initialize()\n            return item ? item[childIdentifierAttribute] : null\n        },\n        deserializer: function(identifierValue, done, context) {\n            if (!initialized)\n                initialize()\n            if (identifierValue === null || identifierValue === undefined)\n                done(null, identifierValue)\n            else\n                lookupFn(identifierValue, done, context)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { SKIP } from \"../constants\"\nimport {\n    invariant,\n    isPropSchema,\n    isAliasedPropSchema,\n    parallel,\n    processAdditionalPropArgs\n} from \"../utils/utils\"\nimport { onAfterDeserialize, onBeforeDeserialize } from \"../core/deserialize\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function list(propSchema, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema),\n        \"provided prop is aliased, please put aliases first\")\n    var result = {\n        serializer: function (ar) {\n            if (ar === undefined) {\n                return SKIP\n            }\n            invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\")\n            return ar.map(propSchema.serializer)\n        },\n        deserializer: function (jsonArray, done, context) {\n            if (!Array.isArray(jsonArray))\n                return void done(\"[serializr] expected JSON array\")\n\n            function processItem(jsonValue, onItemDone, itemIndex) {\n                function callbackBefore(err, value) {\n                    if (!err) {\n                        propSchema.deserializer(value, deserializeDone, context)\n                    } else {\n                        onItemDone(err)\n                    }\n                }\n\n                function deserializeDone(err, value) {\n                    if (typeof propSchema.afterDeserialize === \"function\") {\n                        onAfterDeserialize(callbackAfter, err, value, jsonValue, itemIndex, context,\n                            propSchema)\n                    } else {\n                        onItemDone(err, value)\n                    }\n                }\n\n                function callbackAfter(errPreliminary, finalOrRetryValue) {\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\n                        typeof propSchema.afterDeserialize === \"function\") {\n\n                        propSchema.deserializer(\n                            finalOrRetryValue,\n                            deserializeDone,\n                            context\n                        )\n                    } else {\n                        onItemDone(errPreliminary, finalOrRetryValue)\n                    }\n                }\n\n                onBeforeDeserialize(callbackBefore, jsonValue, jsonArray, itemIndex, context,\n                    propSchema)\n            }\n\n            parallel(\n                jsonArray,\n                processItem,\n                done\n            )\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nexport default function createSimpleSchema(props) {\n    return {\n        factory: function() {\n            return {}\n        },\n        props: props\n    }\n}\n","/*\n * Deserialization\n */\nimport { invariant } from \"../utils/utils\"\nimport { getTargetContext } from \"./Context\"\n\n\n/**\n * Cancels an asynchronous deserialization or update operation for the specified target object.\n * @param instance object that was previously returned from deserialize or update method\n */\nexport default function cancelDeserialize(instance) {\n    invariant(typeof instance === \"object\" && instance && !Array.isArray(instance), \"cancelDeserialize needs an object\")\n    var context = getTargetContext(instance)\n    if (context) {\n        context.cancelAwaits()\n    }\n}\n","/*\n * Update\n */\n\nimport { invariant, isModelSchema, GUARDED_NOOP } from \"../utils/utils\"\nimport getDefaultModelSchema from \"../api/getDefaultModelSchema\"\nimport Context from \"./Context\"\nimport { deserializePropsWithSchema } from \"./deserialize\"\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nexport default function update(modelSchema, target, json, callback, customArgs) {\n    var inferModelSchema =\n        arguments.length === 2 // only target and json\n        || typeof arguments[2] === \"function\" // callback as third arg\n\n    if (inferModelSchema) {\n        target = arguments[0]\n        modelSchema = getDefaultModelSchema(target)\n        json = arguments[1]\n        callback = arguments[2]\n        customArgs = arguments[3]\n    } else {\n        modelSchema = getDefaultModelSchema(modelSchema)\n    }\n    invariant(isModelSchema(modelSchema), \"update failed to determine schema\")\n    invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\")\n    var context = new Context(null, modelSchema, json, callback, customArgs)\n    context.setTarget(target)\n    var lock = context.createCallback(GUARDED_NOOP)\n    var result = deserializePropsWithSchema(context, modelSchema, json, target)\n    lock()\n    return result\n}\n","import { invariant, processAdditionalPropArgs } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\nfunction defaultRegisterFunction(id, value, context) {\n    context.rootContext.resolve(context.modelSchema, id, context.target)\n}\n\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n *\n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n *\n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n *\n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param { RegisterFunction | AdditionalPropArgs } arg1 optional registerFn: function to register this object during creation.\n * @param {AdditionalPropArgs} arg2 optional object that contains beforeDeserialize and/or afterDeserialize handlers\n *\n * @returns {PropSchema}\n */\nexport default function identifier(arg1, arg2) {\n    var registerFn, additionalArgs\n    if (typeof arg1 === \"function\") {\n        registerFn = arg1\n        additionalArgs = arg2\n    } else {\n        additionalArgs = arg1\n    }\n    invariant(!additionalArgs || typeof additionalArgs === \"object\", \"Additional property arguments should be an object, register function should be omitted or a funtion\")\n    var result = {\n        identifier: true,\n        serializer: _defaultPrimitiveProp.serializer,\n        deserializer: function (jsonValue, done, context) {\n            _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\n                defaultRegisterFunction(id, context.target, context)\n                if (registerFn)\n                    registerFn(id, context.target, context)\n                done(err, id)\n            })\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { invariant, processAdditionalPropArgs } from \"../utils/utils\"\n\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function date(additionalArgs) {\n    // TODO: add format option?\n    var result = {\n        serializer: function(value) {\n            if (value === null || value === undefined)\n                return value\n            invariant(value instanceof Date, \"Expected Date object\")\n            return value.getTime()\n        },\n        deserializer: function (jsonValue, done) {\n            if (jsonValue === null || jsonValue === undefined)\n                return void done(null, jsonValue)\n            return void done(null, new Date(jsonValue))\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import { invariant, isPropSchema, isAliasedPropSchema, isIdentifierPropSchema } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\n\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nexport default function alias(name, propSchema) {\n    invariant(name && typeof name === \"string\", \"expected prop name as first argument\")\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\")\n    return {\n        jsonname: name,\n        serializer: propSchema.serializer,\n        deserializer: propSchema.deserializer,\n        identifier: isIdentifierPropSchema(propSchema),\n        beforeDeserialize: propSchema.beforeDeserialize,\n        afterDeserialize: propSchema.afterDeserialize\n    }\n}\n","import {invariant, processAdditionalPropArgs} from \"../utils/utils\"\n\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the following signature for synchronous processing\n * `(value, context, oldValue) => void`\n\n * For asynchronous processing the function expects the following signature\n * `(value, context, oldValue, callback) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schemaDefault = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\n *\n * var schemaWithAsyncProps = _.createSimpleSchema({\n *     a: _.customAsync(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v, context, oldValue, callback) {\n *             somePromise(v, context, oldValue).then((result) => {\n *                 callback(null, result - 2)\n *             }.catch((err) => {\n *                 callback(err)\n *             }\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\n *   t.deepEqual(res.a, 4)\n * };\n\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function custom(serializer, deserializer, additionalArgs) {\n    invariant(typeof serializer === \"function\", \"first argument should be function\")\n    invariant((typeof deserializer === \"function\"), \"second argument should be a function or promise\")\n    var result = {\n        serializer: serializer,\n        deserializer: function (jsonValue, done, context, oldValue) {\n            if (deserializer.length === 4) {\n                deserializer(jsonValue, context, oldValue, done, additionalArgs)\n            } else {\n                done(null, deserializer(jsonValue, context, oldValue, null, additionalArgs))\n            }\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n","import {invariant, isAliasedPropSchema, isPropSchema, isMapLike, processAdditionalPropArgs} from \"../utils/utils\"\nimport {_defaultPrimitiveProp} from \"../constants\"\nimport list from \"./list\"\n\n/**\n * Similar to list, but map represents a string keyed dynamic collection.\n * This can be both plain objects (default) or ES6 Map like structures.\n * This will be inferred from the initial value of the targetted attribute.\n *\n * @param {*} propSchema\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function map(propSchema, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\")\n    var res = {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\n            var isMap = isMapLike(m)\n            var result = {}\n            if (isMap)\n                m.forEach(function (value, key) {\n                    result[key] = propSchema.serializer(value)\n                })\n            else for (var key in m)\n                result[key] = propSchema.serializer(m[key])\n            return result\n        },\n        deserializer: function (jsonObject, done, context, oldValue) {\n            if (!jsonObject || typeof jsonObject !== \"object\")\n                return void done(\"[serializr] expected JSON object\")\n            var keys = Object.keys(jsonObject)\n            list(propSchema, additionalArgs).deserializer(\n                keys.map(function (key) {\n                    return jsonObject[key]\n                }),\n                function (err, values) {\n                    if (err)\n                        return void done(err)\n                    var isMap = isMapLike(oldValue)\n                    var newValue\n                    if (isMap) {\n                        // if the oldValue is a map, we recycle it\n                        // there are many variations and this way we don't have to\n                        // know about the original constructor\n                        oldValue.clear()\n                        newValue = oldValue\n                    } else\n                        newValue = {}\n                    for (var i = 0, l = keys.length; i < l; i++)\n                        if (isMap)\n                            newValue.set(keys[i], values[i])\n                        else\n                            newValue[keys[i]] = values[i]\n                    done(null, newValue)\n                },\n                context\n            )\n        }\n    }\n    res = processAdditionalPropArgs(res, additionalArgs)\n    return res\n}\n","import { invariant, isPropSchema, isMapLike, processAdditionalPropArgs } from \"../utils/utils\"\nimport { _defaultPrimitiveProp } from \"../constants\"\nimport list from \"./list\"\n\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is\n * contained in the 'value object'. Example: consider Map<id: number, customer: Customer> where the\n * Customer object has the id stored on itself. mapAsArray stores all values from the map into an\n * array which is serialized. Deserialization returns a ES6 Map or plain object object where the\n * `keyPropertyName` of each object is used for keys. For ES6 maps this has the benefit of being\n * allowed to have non-string keys in the map. The serialized json also may be slightly more\n * compact.\n *\n * @param {any} propSchema\n * @param {string} keyPropertyName - the property of stored objects used as key in the map\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nexport default function mapAsArray(propSchema, keyPropertyName, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\")\n    invariant(!!keyPropertyName, \"expected key property name as second argument\")\n    var res = {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\")\n            var isMap = isMapLike(m)\n            var result = []\n            // eslint-disable-next-line no-unused-vars\n            if (isMap) {\n                m.forEach(function (value) {\n                    result.push(propSchema.serializer(value))\n                })\n            } else for (var key in m) {\n                result.push(propSchema.serializer(m[key]))\n                // result[key] = propSchema.serializer(m[key])\n            }\n            return result\n        },\n        deserializer: function (jsonArray, done, context, oldValue) {\n            list(propSchema, additionalArgs).deserializer(\n                jsonArray,\n                function (err, values) {\n                    if (err)\n                        return void done(err)\n                    var isMap = isMapLike(oldValue)\n                    var newValue\n                    if (isMap) {\n                        oldValue.clear()\n                        newValue = oldValue\n                    } else {\n                        newValue = {}\n                    }\n                    for (var i = 0, l = jsonArray.length; i < l; i++)\n                        if (isMap)\n                            newValue.set(values[i][keyPropertyName], values[i])\n                        else\n                            newValue[values[i][keyPropertyName].toString()] = values[i]\n                    done(null, newValue)\n                },\n                context\n            )\n        }\n    }\n    res = processAdditionalPropArgs(res, additionalArgs)\n    return res\n}\n","import {processAdditionalPropArgs} from \"../utils/utils\"\n\n/**\n * Indicates that this field is only need to putted in the serialized json or\n * deserialized instance, without any transformations. Stay with its original value\n *\n * @example\n * createModelSchema(Model, {\n *     rawData: raw(),\n * });\n *\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\nexport default function raw(additionalArgs) {\n    var result = {\n        serializer: function (value) {\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            return void done(null, jsonValue)\n        }\n    }\n    result = processAdditionalPropArgs(result, additionalArgs)\n    return result\n}\n"],"names":["formatters","j","v","JSON","stringify","error","message","invariant","condition","variables","Array","prototype","slice","call","arguments","variablesToLog","index","formattedMessage","replace","match","format","formatter","variable","push","console","length","log","apply","Error","GUARDED_NOOP","err","parallel","ar","processor","cb","left","filter","resultArray","failed","forEach","value","idx","result","bind","isPrimitive","isModelSchema","thing","factory","props","isPropSchema","serializer","deserializer","isAliasedPropSchema","propSchema","jsonname","isIdentifierPropSchema","identifier","isAssignableTo","actualType","expectedType","extends","isMapLike","keys","clear","processAdditionalPropArgs","additionalArgs","argName","getDefaultModelSchema","serializeInfo","constructor","setDefaultModelSchema","clazz","modelSchema","createModelSchema","Object","model","targetClass","s","primitive","jsonValue","done","SKIP","Symbol","_defaultPrimitiveProp","STRIP_COMMENTS","ARGUMENT_NAMES","serializableDecorator","target","propName","descriptor","fnStr","undefined","paramNames","toString","indexOf","paramNumber","context","params","i","key","prop","json","Function","concat","info","hasOwnProperty","get","set","writable","serialize","arg1","arg2","schema","isArray","map","item","serializeWithSchema","obj","res","propDef","serializeStarProps","rootContextCache","Map","Context","parentContext","onReadyCb","customArgs","this","isRoot","pendingCallbacks","pendingRefsCount","hasError","rootContext","args","pendingRefs","resolvedRefs","schemaHasAlias","name","deserializeObjectWithSchema","callback","setTarget","lock","createCallback","deserializePropsWithSchema","deserializeStarProps","jsonAttr","onBeforeDeserialize","preProcess","resultCallback","newValue","onAfterDeserialize","errPreliminary","finalOrRetryValue","afterDeserialize","deserializeProp","jsonParentValue","propNameOrIndex","beforeDeserialize","object","childJson","reference","lookupFn","childIdentifierAttribute","initialized","initialize","uuid","await","createDefaultRefLookup","getIdentifierProp","identifierValue","list","jsonArray","onItemDone","itemIndex","deserializeDone","callbackAfter","fn","fired","once","delete","join","resolved","resolve","opts","splice","cancelAwaits","self","refOpts","arg3","instance","items","itemDone","registerFn","id","defaultRegisterFunction","Date","getTime","oldValue","m","isMap","jsonObject","values","l","keyPropertyName"],"mappings":"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"}