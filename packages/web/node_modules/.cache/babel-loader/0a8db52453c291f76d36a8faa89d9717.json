{"ast":null,"code":"/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nfunction createSimpleSchema(props) {\n  return {\n    factory: function factory() {\n      return {};\n    },\n    props: props\n  };\n}\n\nvar formatters = {\n  j: function json(v) {\n    try {\n      return JSON.stringify(v);\n    } catch (error) {\n      return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n  }\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    var variables = Array.prototype.slice.call(arguments, 2);\n    var variablesToLog = [];\n    var index = 0;\n    var formattedMessage = message.replace(/%([a-zA-Z%])/g, function messageFormatter(match, format) {\n      if (match === \"%%\") return match;\n      var formatter = formatters[format];\n\n      if (typeof formatter === \"function\") {\n        var variable = variables[index++];\n        variablesToLog.push(variable);\n        return formatter(variable);\n      }\n\n      return match;\n    });\n\n    if (console && variablesToLog.length > 0) {\n      // eslint-disable-next-line no-console\n      console.log.apply(console, variablesToLog);\n    }\n\n    throw new Error(\"[serializr] \" + (formattedMessage || \"Illegal State\"));\n  }\n}\n\nfunction GUARDED_NOOP(err) {\n  if (err) // unguarded error...\n    throw new Error(err);\n}\n\nfunction once(fn) {\n  var fired = false;\n  return function () {\n    if (!fired) {\n      fired = true;\n      return fn.apply(null, arguments);\n    }\n\n    invariant(false, \"callback was invoked twice\");\n  };\n}\n\nfunction parallel(ar, processor, cb) {\n  // TODO: limit parallelization?\n  if (ar.length === 0) return void cb(null, []);\n  var left = ar.filter(function () {\n    return true;\n  }).length; // only count items processed by forEach\n\n  var resultArray = [];\n  var failed = false;\n\n  var processorCb = function processorCb(idx, err, result) {\n    if (err) {\n      if (!failed) {\n        failed = true;\n        cb(err);\n      }\n    } else {\n      resultArray[idx] = result;\n      if (--left === 0) cb(null, resultArray);\n    }\n  };\n\n  ar.forEach(function (value, idx) {\n    processor(value, processorCb.bind(null, idx), idx);\n  });\n}\n\nfunction isPrimitive(value) {\n  if (value === null) return true;\n  return typeof value !== \"object\" && typeof value !== \"function\";\n}\n\nfunction isModelSchema(thing) {\n  return thing && thing.factory && thing.props;\n}\n\nfunction isPropSchema(thing) {\n  return thing && thing.serializer && thing.deserializer;\n}\n\nfunction isAliasedPropSchema(propSchema) {\n  return typeof propSchema === \"object\" && !!propSchema.jsonname;\n}\n\nfunction isIdentifierPropSchema(propSchema) {\n  return typeof propSchema === \"object\" && propSchema.identifier === true;\n}\n\nfunction isAssignableTo(actualType, expectedType) {\n  while (actualType) {\n    if (actualType === expectedType) return true;\n    actualType = actualType.extends;\n  }\n\n  return false;\n}\n\nfunction isMapLike(thing) {\n  return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\";\n}\n\nfunction getIdentifierProp(modelSchema) {\n  invariant(isModelSchema(modelSchema)); // optimization: cache this lookup\n\n  while (modelSchema) {\n    for (var propName in modelSchema.props) {\n      if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true) return propName;\n    }\n\n    modelSchema = modelSchema.extends;\n  }\n\n  return null;\n}\n\nfunction processAdditionalPropArgs(propSchema, additionalArgs) {\n  if (additionalArgs) {\n    invariant(isPropSchema(propSchema), \"expected a propSchema\");\n    var argNames = [\"beforeDeserialize\", \"afterDeserialize\"];\n    argNames.forEach(function (argName) {\n      if (typeof additionalArgs[argName] === \"function\") {\n        propSchema[argName] = additionalArgs[argName];\n      }\n    });\n  }\n\n  return propSchema;\n}\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\n\n\nfunction getDefaultModelSchema(thing) {\n  if (!thing) return null;\n  if (isModelSchema(thing)) return thing;\n  if (isModelSchema(thing.serializeInfo)) return thing.serializeInfo;\n  if (thing.constructor && thing.constructor.serializeInfo) return thing.constructor.serializeInfo;\n}\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\n\n\nfunction setDefaultModelSchema(clazz, modelSchema) {\n  invariant(isModelSchema(modelSchema));\n  return clazz.serializeInfo = modelSchema;\n}\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\n\n\nfunction createModelSchema(clazz, props, factory) {\n  invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\");\n  invariant(typeof clazz === \"function\", \"expected constructor function\");\n  var model = {\n    targetClass: clazz,\n    factory: factory || function () {\n      return new clazz();\n    },\n    props: props\n  }; // find super model\n\n  if (clazz.prototype.constructor !== Object) {\n    var s = getDefaultModelSchema(clazz.prototype.constructor);\n    if (s && s.targetClass !== clazz) model.extends = s;\n  }\n\n  setDefaultModelSchema(clazz, model);\n  return model;\n}\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\n\n\nfunction primitive(additionalArgs) {\n  var result = {\n    serializer: function serializer(value) {\n      invariant(isPrimitive(value), \"this value is not primitive: \" + value);\n      return value;\n    },\n    deserializer: function deserializer(jsonValue, done) {\n      if (!isPrimitive(jsonValue)) return void done(\"[serializr] this value is not primitive: \" + jsonValue);\n      return void done(null, jsonValue);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\n\n\nvar SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : {\n  SKIP: true\n};\n\nvar _defaultPrimitiveProp = primitive(); // Ugly way to get the parameter names since they aren't easily retrievable via reflection\n\n\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\nfunction getParamNames(func) {\n  var fnStr = func.toString().replace(STRIP_COMMENTS, \"\");\n  var result = fnStr.slice(fnStr.indexOf(\"(\") + 1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES);\n  if (result === null) result = [];\n  return result;\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n  invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\"); // Fix for @serializable used in class constructor params (typescript)\n\n  var factory;\n\n  if (propName === undefined && typeof target === \"function\" && target.prototype && descriptor !== undefined && typeof descriptor === \"number\") {\n    invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\");\n    invariant(propSchema.jsonname, \"Constructor params must use alias(name)\");\n    var paramNames = getParamNames(target);\n\n    if (paramNames.length >= descriptor) {\n      propName = paramNames[descriptor];\n      propSchema.paramNumber = descriptor;\n      descriptor = undefined;\n      target = target.prototype; // Create a factory so the constructor is called properly\n\n      factory = function factory(context) {\n        var params = [];\n\n        for (var i = 0; i < target.constructor.length; i++) {\n          Object.keys(context.modelSchema.props).forEach(function (key) {\n            var prop = context.modelSchema.props[key];\n\n            if (prop.paramNumber === i) {\n              params[i] = context.json[prop.jsonname];\n            }\n          });\n        }\n\n        return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))();\n      };\n    }\n  }\n\n  invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\");\n  var info = getDefaultModelSchema(target);\n  if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\")) info = createModelSchema(target.constructor, {}, factory);\n  if (info && info.targetClass !== target.constructor) // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n    info = createModelSchema(target.constructor, {}, factory);\n  info.props[propName] = propSchema; // MWE: why won't babel work without?\n\n  if (descriptor && !descriptor.get && !descriptor.set) descriptor.writable = true;\n  return descriptor;\n}\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\n\n\nfunction serializable(arg1, arg2, arg3) {\n  if (arguments.length === 1) {\n    // decorated with propSchema\n    var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1;\n    invariant(isPropSchema(propSchema), \"@serializable expects prop schema\");\n    return serializableDecorator.bind(null, propSchema);\n  } else {\n    // decorated without arguments, treat as primitive\n    return serializableDecorator(primitive(), arg1, arg2, arg3);\n  }\n}\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\n\n\nfunction serialize(arg1, arg2) {\n  invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\");\n  var thing = arguments.length === 1 ? arg1 : arg2;\n  var schema = arguments.length === 1 ? null : arg1;\n\n  if (Array.isArray(thing)) {\n    if (thing.length === 0) return []; // don't bother finding a schema\n    else if (!schema) schema = getDefaultModelSchema(thing[0]);\n  } else if (!schema) {\n    schema = getDefaultModelSchema(thing);\n  }\n\n  invariant(!!schema, \"Failed to find default schema for \" + arg1);\n  if (Array.isArray(thing)) return thing.map(function (item) {\n    return serializeWithSchema(schema, item);\n  });\n  return serializeWithSchema(schema, thing);\n}\n\nfunction serializeWithSchema(schema, obj) {\n  invariant(schema && typeof schema === \"object\", \"Expected schema\");\n  invariant(obj && typeof obj === \"object\", \"Expected object\");\n  var res;\n  if (schema.extends) res = serializeWithSchema(schema.extends, obj);else {\n    // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n    res = {};\n  }\n  Object.keys(schema.props).forEach(function (key) {\n    var propDef = schema.props[key];\n\n    if (key === \"*\") {\n      invariant(propDef === true, \"prop schema '*' can only be used with 'true'\");\n      serializeStarProps(schema, obj, res);\n      return;\n    }\n\n    if (propDef === true) propDef = _defaultPrimitiveProp;\n    if (propDef === false) return;\n    var jsonValue = propDef.serializer(obj[key], key, obj);\n\n    if (jsonValue === SKIP) {\n      return;\n    }\n\n    res[propDef.jsonname || key] = jsonValue;\n  });\n  return res;\n}\n\nfunction serializeStarProps(schema, obj, target) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n      var value = obj[key]; // when serializing only serialize primitive props. Assumes other props (without schema) are local state that doesn't need serialization\n\n      if (isPrimitive(value)) target[key] = value;\n    }\n  }\n}\n/**\n * The `serializeAll` decorator can be used on a class to signal that all primitive properties should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { a: 3, b: undefined, c: 5 });\n */\n\n\nfunction serializeAll(target) {\n  invariant(arguments.length === 1 && typeof target === \"function\", \"@serializeAll can only be used as class decorator\");\n  var info = getDefaultModelSchema(target);\n\n  if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n    info = createModelSchema(target, {});\n    setDefaultModelSchema(target, info);\n  }\n\n  getDefaultModelSchema(target).props[\"*\"] = true;\n  return target;\n}\n\nvar rootContextCache = new Map();\n\nfunction Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n  this.parentContext = parentContext;\n  this.isRoot = !parentContext;\n  this.pendingCallbacks = 0;\n  this.pendingRefsCount = 0;\n  this.onReadyCb = onReadyCb || GUARDED_NOOP;\n  this.json = json;\n  this.target = null; // always set this property using setTarget\n\n  this.hasError = false;\n  this.modelSchema = modelSchema;\n\n  if (this.isRoot) {\n    this.rootContext = this;\n    this.args = customArgs;\n    this.pendingRefs = {}; // uuid: [{ modelSchema, uuid, cb }]\n\n    this.resolvedRefs = {}; // uuid: [{ modelSchema, value }]\n  } else {\n    this.rootContext = parentContext.rootContext;\n    this.args = parentContext.args;\n  }\n}\n\nContext.prototype.createCallback = function (fn) {\n  this.pendingCallbacks++; // once: defend against user-land calling 'done' twice\n\n  return once(function (err, value) {\n    if (err) {\n      if (!this.hasError) {\n        this.hasError = true;\n        this.onReadyCb(err);\n        rootContextCache.delete(this);\n      }\n    } else if (!this.hasError) {\n      fn(value);\n\n      if (--this.pendingCallbacks === this.pendingRefsCount) {\n        if (this.pendingRefsCount > 0) {\n          // all pending callbacks are pending reference resolvers. not good.\n          this.onReadyCb(new Error(\"Unresolvable references in json: \\\"\" + Object.keys(this.pendingRefs).filter(function (uuid) {\n            return this.pendingRefs[uuid].length > 0;\n          }, this).join(\"\\\", \\\"\") + \"\\\"\"));\n          rootContextCache.delete(this);\n        } else {\n          this.onReadyCb(null, this.target);\n          rootContextCache.delete(this);\n        }\n      }\n    }\n  }.bind(this));\n}; // given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\n\n\nContext.prototype.await = function (modelSchema, uuid, callback) {\n  invariant(this.isRoot);\n\n  if (uuid in this.resolvedRefs) {\n    var match = this.resolvedRefs[uuid].filter(function (resolved) {\n      return isAssignableTo(resolved.modelSchema, modelSchema);\n    })[0];\n    if (match) return void callback(null, match.value);\n  }\n\n  this.pendingRefsCount++;\n  if (!this.pendingRefs[uuid]) this.pendingRefs[uuid] = [];\n  this.pendingRefs[uuid].push({\n    modelSchema: modelSchema,\n    uuid: uuid,\n    callback: callback\n  });\n}; // given a model schema, uuid and value, resolve all references that where looking for this object\n\n\nContext.prototype.resolve = function (modelSchema, uuid, value) {\n  invariant(this.isRoot);\n  if (!this.resolvedRefs[uuid]) this.resolvedRefs[uuid] = [];\n  this.resolvedRefs[uuid].push({\n    modelSchema: modelSchema,\n    value: value\n  });\n\n  if (uuid in this.pendingRefs) {\n    for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n      var opts = this.pendingRefs[uuid][i];\n\n      if (isAssignableTo(modelSchema, opts.modelSchema)) {\n        this.pendingRefs[uuid].splice(i, 1);\n        this.pendingRefsCount--;\n        opts.callback(null, value);\n      }\n    }\n  }\n}; // set target and update root context cache\n\n\nContext.prototype.setTarget = function (target) {\n  if (this.isRoot && this.target) {\n    rootContextCache.delete(this.target);\n  }\n\n  this.target = target;\n  rootContextCache.set(this.target, this);\n}; // call all remaining reference lookup callbacks indicating an error during ref resolution\n\n\nContext.prototype.cancelAwaits = function () {\n  invariant(this.isRoot);\n  var self = this;\n  Object.keys(this.pendingRefs).forEach(function (uuid) {\n    self.pendingRefs[uuid].forEach(function (refOpts) {\n      self.pendingRefsCount--;\n      refOpts.callback(new Error(\"Reference resolution canceled for \" + uuid));\n    });\n  });\n  this.pendingRefs = {};\n  this.pendingRefsCount = 0;\n};\n\nfunction getTargetContext(target) {\n  return rootContextCache.get(target);\n}\n/*\n * Deserialization\n */\n\n/**\n * Cancels an asynchronous deserialization or update operation for the specified target object.\n * @param instance object that was previously returned from deserialize or update method\n */\n\n\nfunction cancelDeserialize(instance) {\n  invariant(typeof instance === \"object\" && instance && !Array.isArray(instance), \"cancelDeserialize needs an object\");\n  var context = getTargetContext(instance);\n\n  if (context) {\n    context.cancelAwaits();\n  }\n}\n/*\n * Deserialization\n */\n\n\nfunction schemaHasAlias(schema, name) {\n  for (var key in schema.props) {\n    if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name) return true;\n  }\n\n  return false;\n}\n\nfunction deserializeStarProps(schema, obj, json) {\n  for (var key in json) {\n    if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n      var value = json[key]; // when deserializing we don't want to silently ignore 'unparseable data' to avoid\n      // confusing bugs\n\n      invariant(isPrimitive(value), \"encountered non primitive value while deserializing '*' properties in property '\" + key + \"': \" + value);\n      obj[key] = value;\n    }\n  }\n}\n/**\n * Deserializes a json structure into an object graph.\n *\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserialization has\n *   finished. First argument is the optional error, second argument is the deserialized object\n *   (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the\n *   deserialization process. This can be used as dependency injection mechanism to pass in, for\n *   example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\n\n\nfunction deserialize(schema, json, callback, customArgs) {\n  invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\");\n  schema = getDefaultModelSchema(schema);\n  invariant(isModelSchema(schema), \"first argument should be model schema\");\n\n  if (Array.isArray(json)) {\n    var items = [];\n    parallel(json, function (childJson, itemDone) {\n      var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs); // instance is created synchronously so can be pushed\n\n      items.push(instance);\n    }, callback || GUARDED_NOOP);\n    return items;\n  } else return deserializeObjectWithSchema(null, schema, json, callback, customArgs);\n}\n\nfunction deserializeObjectWithSchema(parentContext, modelSchema, json, callback, customArgs) {\n  if (json === null || json === undefined || typeof json !== \"object\") return void callback(null, null);\n  var context = new Context(parentContext, modelSchema, json, callback, customArgs);\n  var target = modelSchema.factory(context); // todo async invariant\n\n  invariant(!!target, \"No object returned from factory\"); // TODO: make invariant?            invariant(schema.extends ||\n  // !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable\n  // supertype, but modelschema did not provide extends clause\")\n\n  context.setTarget(target);\n  var lock = context.createCallback(GUARDED_NOOP);\n  deserializePropsWithSchema(context, modelSchema, json, target);\n  lock();\n  return target;\n}\n\nfunction deserializePropsWithSchema(context, modelSchema, json, target) {\n  if (modelSchema.extends) deserializePropsWithSchema(context, modelSchema.extends, json, target);\n\n  function deserializeProp(propDef, jsonValue, propName) {\n    function setValue(value) {\n      if (value !== SKIP) {\n        target[propName] = value;\n      }\n    }\n\n    function preProcess(resultCallback) {\n      return function (err, newValue) {\n        function finalCallback(errPreliminary, finalOrRetryValue) {\n          if (errPreliminary && finalOrRetryValue !== undefined && typeof propDef.afterDeserialize === \"function\") {\n            propDef.deserializer(finalOrRetryValue, preProcess(resultCallback), context, target[propName]);\n          } else {\n            resultCallback(errPreliminary, finalOrRetryValue);\n          }\n        }\n\n        onAfterDeserialize(finalCallback, err, newValue, jsonValue, json, propName, context, propDef);\n      };\n    }\n\n    propDef.deserializer(jsonValue, // for individual props, use root context based callbacks\n    // this allows props to complete after completing the object itself\n    // enabling reference resolving and such\n    preProcess(context.rootContext.createCallback(setValue)), context, target[propName] // initial value\n    );\n  }\n\n  Object.keys(modelSchema.props).forEach(function (propName) {\n    var propDef = modelSchema.props[propName];\n\n    function callbackDeserialize(err, jsonValue) {\n      if (!err && jsonValue !== undefined) {\n        deserializeProp(propDef, jsonValue, propName);\n      }\n    }\n\n    if (propName === \"*\") {\n      invariant(propDef === true, \"prop schema '*' can only be used with 'true'\");\n      deserializeStarProps(modelSchema, target, json);\n      return;\n    }\n\n    if (propDef === true) propDef = _defaultPrimitiveProp;\n    if (propDef === false) return;\n    var jsonAttr = propDef.jsonname || propName;\n    var jsonValue = json[jsonAttr];\n    onBeforeDeserialize(callbackDeserialize, jsonValue, json, jsonAttr, context, propDef);\n  });\n}\n\nfunction onBeforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n  if (propDef && typeof propDef.beforeDeserialize === \"function\") {\n    propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef);\n  } else {\n    callback(null, jsonValue);\n  }\n}\n\nfunction onAfterDeserialize(callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n  if (propDef && typeof propDef.afterDeserialize === \"function\") {\n    propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef);\n  } else {\n    callback(err, newValue);\n  }\n}\n/*\n * Update\n */\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\n\n\nfunction update(modelSchema, target, json, callback, customArgs) {\n  var inferModelSchema = arguments.length === 2 // only target and json\n  || typeof arguments[2] === \"function\"; // callback as third arg\n\n  if (inferModelSchema) {\n    target = arguments[0];\n    modelSchema = getDefaultModelSchema(target);\n    json = arguments[1];\n    callback = arguments[2];\n    customArgs = arguments[3];\n  } else {\n    modelSchema = getDefaultModelSchema(modelSchema);\n  }\n\n  invariant(isModelSchema(modelSchema), \"update failed to determine schema\");\n  invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\");\n  var context = new Context(null, modelSchema, json, callback, customArgs);\n  context.setTarget(target);\n  var lock = context.createCallback(GUARDED_NOOP);\n  var result = deserializePropsWithSchema(context, modelSchema, json, target);\n  lock();\n  return result;\n}\n\nfunction defaultRegisterFunction(id, value, context) {\n  context.rootContext.resolve(context.modelSchema, id, context.target);\n}\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n *\n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n *\n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n *\n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param { RegisterFunction | AdditionalPropArgs } arg1 optional registerFn: function to register this object during creation.\n * @param {AdditionalPropArgs} arg2 optional object that contains beforeDeserialize and/or afterDeserialize handlers\n *\n * @returns {PropSchema}\n */\n\n\nfunction identifier(arg1, arg2) {\n  var registerFn, additionalArgs;\n\n  if (typeof arg1 === \"function\") {\n    registerFn = arg1;\n    additionalArgs = arg2;\n  } else {\n    additionalArgs = arg1;\n  }\n\n  invariant(!additionalArgs || typeof additionalArgs === \"object\", \"Additional property arguments should be an object, register function should be omitted or a funtion\");\n  var result = {\n    identifier: true,\n    serializer: _defaultPrimitiveProp.serializer,\n    deserializer: function deserializer(jsonValue, done, context) {\n      _defaultPrimitiveProp.deserializer(jsonValue, function (err, id) {\n        defaultRegisterFunction(id, context.target, context);\n        if (registerFn) registerFn(id, context.target, context);\n        done(err, id);\n      });\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction date(additionalArgs) {\n  // TODO: add format option?\n  var result = {\n    serializer: function serializer(value) {\n      if (value === null || value === undefined) return value;\n      invariant(value instanceof Date, \"Expected Date object\");\n      return value.getTime();\n    },\n    deserializer: function deserializer(jsonValue, done) {\n      if (jsonValue === null || jsonValue === undefined) return void done(null, jsonValue);\n      return void done(null, new Date(jsonValue));\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\n\n\nfunction alias(name, propSchema) {\n  invariant(name && typeof name === \"string\", \"expected prop name as first argument\");\n  propSchema = !propSchema || propSchema === true ? _defaultPrimitiveProp : propSchema;\n  invariant(isPropSchema(propSchema), \"expected prop schema as second argument\");\n  invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\");\n  return {\n    jsonname: name,\n    serializer: propSchema.serializer,\n    deserializer: propSchema.deserializer,\n    identifier: isIdentifierPropSchema(propSchema),\n    beforeDeserialize: propSchema.beforeDeserialize,\n    afterDeserialize: propSchema.afterDeserialize\n  };\n}\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the following signature for synchronous processing\n * `(value, context, oldValue) => void`\n\n * For asynchronous processing the function expects the following signature\n * `(value, context, oldValue, callback) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schemaDefault = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\n *\n * var schemaWithAsyncProps = _.createSimpleSchema({\n *     a: _.customAsync(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v, context, oldValue, callback) {\n *             somePromise(v, context, oldValue).then((result) => {\n *                 callback(null, result - 2)\n *             }.catch((err) => {\n *                 callback(err)\n *             }\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\n *   t.deepEqual(res.a, 4)\n * };\n\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction custom(serializer, _deserializer, additionalArgs) {\n  invariant(typeof serializer === \"function\", \"first argument should be function\");\n  invariant(typeof _deserializer === \"function\", \"second argument should be a function or promise\");\n  var result = {\n    serializer: serializer,\n    deserializer: function deserializer(jsonValue, done, context, oldValue) {\n      if (_deserializer.length === 4) {\n        _deserializer(jsonValue, context, oldValue, done, additionalArgs);\n      } else {\n        done(null, _deserializer(jsonValue, context, oldValue, null, additionalArgs));\n      }\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction object(modelSchema, additionalArgs) {\n  invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\");\n  var result = {\n    serializer: function serializer(item) {\n      modelSchema = getDefaultModelSchema(modelSchema);\n      invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema);\n      if (item === null || item === undefined) return item;\n      return serialize(modelSchema, item);\n    },\n    deserializer: function deserializer(childJson, done, context) {\n      modelSchema = getDefaultModelSchema(modelSchema);\n      invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema);\n      if (childJson === null || childJson === undefined) return void done(null, childJson);\n      return void deserializeObjectWithSchema(context, modelSchema, childJson, done, additionalArgs);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n\nfunction createDefaultRefLookup(modelSchema) {\n  return function resolve(uuid, cb, context) {\n    context.rootContext.await(modelSchema, uuid, cb);\n  };\n}\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction | AdditionalPropArgs} lookupFn optional function or additionalArgs object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction reference(target, lookupFn, additionalArgs) {\n  invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\");\n  var initialized = false;\n  var childIdentifierAttribute;\n\n  if (typeof lookupFn === \"object\" && additionalArgs === undefined) {\n    additionalArgs = lookupFn;\n    lookupFn = undefined;\n  }\n\n  function initialize() {\n    initialized = true;\n    invariant(typeof target !== \"string\" || lookupFn && typeof lookupFn === \"function\", \"if the reference target is specified by attribute name, a lookup function is required\");\n    invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function or additional arguments object\");\n    if (typeof target === \"string\") childIdentifierAttribute = target;else {\n      var modelSchema = getDefaultModelSchema(target);\n      invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema);\n      lookupFn = lookupFn || createDefaultRefLookup(modelSchema);\n      childIdentifierAttribute = getIdentifierProp(modelSchema);\n      invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\");\n    }\n  }\n\n  var result = {\n    serializer: function serializer(item) {\n      if (!initialized) initialize();\n      return item ? item[childIdentifierAttribute] : null;\n    },\n    deserializer: function deserializer(identifierValue, done, context) {\n      if (!initialized) initialize();\n      if (identifierValue === null || identifierValue === undefined) done(null, identifierValue);else lookupFn(identifierValue, done, context);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction list(propSchema, additionalArgs) {\n  propSchema = propSchema || _defaultPrimitiveProp;\n  invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n  invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\");\n  var result = {\n    serializer: function serializer(ar) {\n      if (ar === undefined) {\n        return SKIP;\n      }\n\n      invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\");\n      return ar.map(propSchema.serializer);\n    },\n    deserializer: function deserializer(jsonArray, done, context) {\n      if (!Array.isArray(jsonArray)) return void done(\"[serializr] expected JSON array\");\n\n      function processItem(jsonValue, onItemDone, itemIndex) {\n        function callbackBefore(err, value) {\n          if (!err) {\n            propSchema.deserializer(value, deserializeDone, context);\n          } else {\n            onItemDone(err);\n          }\n        }\n\n        function deserializeDone(err, value) {\n          if (typeof propSchema.afterDeserialize === \"function\") {\n            onAfterDeserialize(callbackAfter, err, value, jsonValue, itemIndex, context, propSchema);\n          } else {\n            onItemDone(err, value);\n          }\n        }\n\n        function callbackAfter(errPreliminary, finalOrRetryValue) {\n          if (errPreliminary && finalOrRetryValue !== undefined && typeof propSchema.afterDeserialize === \"function\") {\n            propSchema.deserializer(finalOrRetryValue, deserializeDone, context);\n          } else {\n            onItemDone(errPreliminary, finalOrRetryValue);\n          }\n        }\n\n        onBeforeDeserialize(callbackBefore, jsonValue, jsonArray, itemIndex, context, propSchema);\n      }\n\n      parallel(jsonArray, processItem, done);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Similar to list, but map represents a string keyed dynamic collection.\n * This can be both plain objects (default) or ES6 Map like structures.\n * This will be inferred from the initial value of the targetted attribute.\n *\n * @param {*} propSchema\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction map(propSchema, additionalArgs) {\n  propSchema = propSchema || _defaultPrimitiveProp;\n  invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n  invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\");\n  var res = {\n    serializer: function serializer(m) {\n      invariant(m && typeof m === \"object\", \"expected object or Map\");\n      var isMap = isMapLike(m);\n      var result = {};\n      if (isMap) m.forEach(function (value, key) {\n        result[key] = propSchema.serializer(value);\n      });else for (var key in m) {\n        result[key] = propSchema.serializer(m[key]);\n      }\n      return result;\n    },\n    deserializer: function deserializer(jsonObject, done, context, oldValue) {\n      if (!jsonObject || typeof jsonObject !== \"object\") return void done(\"[serializr] expected JSON object\");\n      var keys = Object.keys(jsonObject);\n      list(propSchema, additionalArgs).deserializer(keys.map(function (key) {\n        return jsonObject[key];\n      }), function (err, values) {\n        if (err) return void done(err);\n        var isMap = isMapLike(oldValue);\n        var newValue;\n\n        if (isMap) {\n          // if the oldValue is a map, we recycle it\n          // there are many variations and this way we don't have to\n          // know about the original constructor\n          oldValue.clear();\n          newValue = oldValue;\n        } else newValue = {};\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          if (isMap) newValue.set(keys[i], values[i]);else newValue[keys[i]] = values[i];\n        }\n\n        done(null, newValue);\n      }, context);\n    }\n  };\n  res = processAdditionalPropArgs(res, additionalArgs);\n  return res;\n}\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is\n * contained in the 'value object'. Example: consider Map<id: number, customer: Customer> where the\n * Customer object has the id stored on itself. mapAsArray stores all values from the map into an\n * array which is serialized. Deserialization returns a ES6 Map or plain object object where the\n * `keyPropertyName` of each object is used for keys. For ES6 maps this has the benefit of being\n * allowed to have non-string keys in the map. The serialized json also may be slightly more\n * compact.\n *\n * @param {any} propSchema\n * @param {string} keyPropertyName - the property of stored objects used as key in the map\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction mapAsArray(propSchema, keyPropertyName, additionalArgs) {\n  propSchema = propSchema || _defaultPrimitiveProp;\n  invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n  invariant(!!keyPropertyName, \"expected key property name as second argument\");\n  var res = {\n    serializer: function serializer(m) {\n      invariant(m && typeof m === \"object\", \"expected object or Map\");\n      var isMap = isMapLike(m);\n      var result = []; // eslint-disable-next-line no-unused-vars\n\n      if (isMap) {\n        m.forEach(function (value) {\n          result.push(propSchema.serializer(value));\n        });\n      } else for (var key in m) {\n        result.push(propSchema.serializer(m[key])); // result[key] = propSchema.serializer(m[key])\n      }\n\n      return result;\n    },\n    deserializer: function deserializer(jsonArray, done, context, oldValue) {\n      list(propSchema, additionalArgs).deserializer(jsonArray, function (err, values) {\n        if (err) return void done(err);\n        var isMap = isMapLike(oldValue);\n        var newValue;\n\n        if (isMap) {\n          oldValue.clear();\n          newValue = oldValue;\n        } else {\n          newValue = {};\n        }\n\n        for (var i = 0, l = jsonArray.length; i < l; i++) {\n          if (isMap) newValue.set(values[i][keyPropertyName], values[i]);else newValue[values[i][keyPropertyName].toString()] = values[i];\n        }\n\n        done(null, newValue);\n      }, context);\n    }\n  };\n  res = processAdditionalPropArgs(res, additionalArgs);\n  return res;\n}\n/**\n * Indicates that this field is only need to putted in the serialized json or\n * deserialized instance, without any transformations. Stay with its original value\n *\n * @example\n * createModelSchema(Model, {\n *     rawData: raw(),\n * });\n *\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\n\n\nfunction raw(additionalArgs) {\n  var result = {\n    serializer: function serializer(value) {\n      return value;\n    },\n    deserializer: function deserializer(jsonValue, done) {\n      return void done(null, jsonValue);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/*\n * ## Managing model schemas\n */\n// ~ deprecated\n\n\nexport { createSimpleSchema, createModelSchema, getDefaultModelSchema, setDefaultModelSchema, serializable, serialize, serializeAll, cancelDeserialize, deserialize, update, primitive, identifier, date, alias, custom, object, object as child, reference, reference as ref, list, map, mapAsArray, raw, SKIP };","map":null,"metadata":{},"sourceType":"module"}